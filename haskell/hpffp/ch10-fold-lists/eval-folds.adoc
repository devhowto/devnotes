= Evaluating Folds :: Haskell
:page-tags: haskell list eval fold foldr foldl
:imagesdir: ../../__assets

== foldr and foldr implementation

We are naming them `fldr` and `fldl` so they don't conflict with standard `foldr` and `foldl`.

.fldr and fldr
[source,haskell]
----
fldr :: (a -> b -> b) -> b -> [a] -> b
fldr _ acc []       = acc
fldr f acc (x : xs) = f x (fldr f acc xs)

fldl :: (b -> a -> b) -> b -> [a] -> b
fldl _ acc []       = acc
fldl f acc (x : xs) = fldl f (f acc x) xs
----

== eval foldr with (+)

[source,text]
----
f = (+)

fldr f 0 [1, 2, 3]
f 1 (fldr f 0 [2, 3])
f 1 (f 2 (fldr f 0 [3]))
f 1 (f 2 (f 3 (fldr f 0 [])))
f 1 (f 2 (f 3 0))
f 1 (f 2 3)
f 1 5
f 6
----

== eval foldr with cons (:)

[source,text]
----
fldr :: (a -> b -> b) -> b -> [a] -> b
fldr _ z []       = z
fldr f z (x : xs) = f x (fldr f z xs)

fldr (:) [] [1, 2, 3]

(:) 1 (fldr (:) [] [2, 3])

(:) 1 ((:) 2 (fldr (:) [] [3]))

(:) 1 ((:) 2 ((:) 3 (fldr (:) [] [])))

(:) 1 ((:) 2 ((:) 3 []))

(:) 1 ((:) 2 [3])

(:) 1 [2, 3]

[1, 2, 3]
----

== eval foldl with flipped cons (:)

[source,text]
----
fldl :: (b -> a -> b) -> b -> [a] -> b
fldl _ acc []       = acc
fldl f acc (x : xs) = fldl f (f acc x) xs
----

Note the signature of the ``foldl``'s folding function:

[source,text]
----
(b -> a -> b)
----

The first stem:[b] is the type of the accumulator, then stem:[a] is the type of the elements of the list.
The final stem:[b] is the return value.
If folding a list of type `[Int]`, stem:[b] would be the list itself.


[source,text]
----
fdl :: (b -> a -> b) -> b -> [a] -> b
fdl _ acc []       = acc
fdl f acc (x : xs) = fldl f (f acc x) xs

fdl (:) [] [1, 2, 3]

fdl (:) ([] : 1) [2, 3]
         ------
            \
             \
              +--> Wrong. Should be 1 : [] instead.
----

That is why we must _flip_ `:` with `foldl`.

[source,text]
----
f = flip (:)

fldl f [] [1, 2, 3]

fldl f (f acc 1) [2, 3]
         [1]

fdl f (f [1] 2) [3]
       [2, 1]

fdl f (f [2, 1] 3) []
       [3, 2, 1]

((([] `f` 1) `f` 2) `f` 3)
 (([1] `f` 2) `f` 3)
   ([2, 1] `f` 3)
    [3, 2, 1]
----

