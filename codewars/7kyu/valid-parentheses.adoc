= Valid Parenthesis | 7kyu Codewars Challenge
:icons: font
:sectlinks:
:sectnums!:
:toclevels: 6
:toc: left
:favicon: https://fernandobasso.dev/cmdline.png

* link:https://www.codewars.com/kata/6411b91a5e71b915d237332d[Valid Parenthesis 7kyu Codewars challenge^]

In the comments, people say this problem should bin in the 6kyu category.

Examples:

----
""                //=> true
"("               //=> false
"(("              //=> false
")(()))"          //=> false
"()"              //=> true
"()()"            //=> true
"((()))"          //=> true
"())()("          //=> false
"(())((()())())"  //=> true
----

== JavaScript

=== v1

[source,javascript]
----
/**
 * Recursive solution using the run/go helper function approach.
 *
 * - T.C: O(n).
 * - S.C: O(n).
 *
 * @param {string}
 * @returns {number}
 */
function validParens(s) {
  return (function go(lst, l, r) {
    if (lst.length === 0) return l === r;

    if (lst[0] === '(') ++l;
    if (lst[0] === ')') ++r;

    if (r > l) return false;

    return go(lst.slice(1), l, r);
  })([...s], 0, 0);
}
----

=== v2

[source,js]
----
/**
 * @param {string}
 * @returns {number}
 */
function validParens(s) {
  return (function go(l, c) {
    if (l.length === 0) return c === 0;

    if (l[0] === '(') ++c;
    if (l[0] === ')') --c;

    if (c < 0) return false;

    return go(l.slice(1), c);
  })([...s], 0);
}
----

== Haskell

=== v1

[source,haskell]
----
incIf :: Char -> Char -> Int -> Int
incIf c1 c2 n
  | c1 == c2 = (+ 1) n
  | otherwise = n

validParens :: String -> Bool
validParens str = go str 0 0
  where
    go :: String -> Int -> Int -> Bool
    go s l r
      | length s == 0 = l == r
      | r > l = False
      | otherwise = go
                    (tail s)
                    (incIf (head s) '(' l)
                    (incIf (head s) ')' r)
----

=== v2

This was a solution I saw from user _monadius_:

[source,haskell]
----
validParens :: String -> Bool
validParens str = (== 0) count
  where count = foldr
                (\c n ->
                    if n < 0 then n
                    else if c == '('
                         then n - 1
                         else n + 1) 0 str
----

I could not make sense of it then changed it a little bit and asked on link:https://discord.com/channels/280033776820813825/505367988166197268/1117771069521154048[Discord Haskell server^].

Basically, this is `foldr`, which means the `n` input will be passed the result of folding the tail.

If it was `foldl`` then the n input would be the accumulated result for everything folded over so far, but since it is `foldr , it is instead passed the result of the tail, which means whether the lambda accumulates `n` has no bearing of what `n` will be during the folding of the tail.
