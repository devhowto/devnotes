= Prime Factors of a Number
:page-subtitle: Algorithms and Data Structures
:toc: left
:icons: font
:sectlinks:
:source-highlighter: pygments
:stem: latexmath

== Intro

For an introduction on prime factorization, peruse link:https://www.mathsisfun.com/prime-factorization.html[Prime Factorization article on Math Is Fun^].

People implement solutions with loop testing divisibility only up to the square root of the target number.

.Python solution excerpt
[source,python]
----
while i <= int(sqrt(n))
----

.C solution excerpt
[source,c]
----
while (i <= (int)sqrt((double)n)))
----

We can avoid having to deal with doubles vs ints and the use of `sqrt()` by using stem:[i * i \le n] instead of stem:[i \le sqrt(n)].

More info on this link:https://stackoverflow.com/a/5811176/2855955[Stack Overflow Answer^].

== Recursive Solution in C

Here's one solution from the book Mastering Algorithms with C, with my own modifications to return a pointer to an array of prime factors instead of printing them.

[source,c]
----
#include <stdio.h>
#include <stdlib.h>

int factor(int x, int n, int j, int *ps, int idx) {
  int i;

  if (n == 1) {
    printf("1 is a unit.\n");
    return ++idx;
  }

  i = j;

  while (i * i <= n) {
    if (n % i == 0) {
      *(ps + idx) = i;
      factor(x, (int)(n / i), i, ps, ++idx);
      return ++idx;
    } else {
      ++i;
    }
  }

  if (n == x)
    printf("%d is prime.\n", x);
  else
    *(ps + idx) = n;

  return ++idx;
}

int main(void) {
  int *ps = malloc(sizeof(int) * 4);
  int i, len;

  len = factor(18, 18, 2, ps, 0);

  for (i = 0; i <= len; ++i)
    printf("%d\n", *(ps + i));

  free(ps);
}

----

## Recursive solution in Python

[source,python]
----
def factors(x, n, j, ps = []):
  if n == 1:
    return 1

  i = j
  while i * i <= n:
    if n % i == 0:
      ps.append(i)
      factors(x, int(n / i), i, ps)
      return ps
    else:
      i = i + 1

  if x == n:
    return "%d is prime" % x
  else:
    ps.append(n)
    return ps

print(factors(18, 18, 2, []))
#=> [2, 3, 3]
----
