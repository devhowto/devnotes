= Doubly Linked Lists
:page-tags: data-structure list singly-linked-list
:toc: right
:stem: latexmath
:icons: font

== Intro to Doubly Linked Lists

image::./doubly-linked-lists.assets/doubly-linked-lists-intro.png[Doubly Linked Lists]

Structurally similar to singly linked lists, except every node also has a pointer to the *previous* node.
Doesn't change much in the structures, but allows a more performant implementation of some of its operations.

* No indexes.
* Nodes are connected through `next` and `prev` _pointers_.
* No random access (have to “walk the list”, but now can also traverse backwards).
* Inexpensive insertion and deletion.

Sometimes, reversing a doubly linked list is not necessary as we *can* traverse backwards.

The implementation of the operations get a little more complicated because now two pointers (`prev` and `next`) have to be accounted for.

Because two pointers on each node (`prev` and `next`, instead of just `next` for singly linked lists), more memory is required.

== Node Class

[source,js]
----
class Node {
  constructor(val) {
    this.val = val;
    this.prev = null;
    this.next = null;
  }
}

var foo = new Node(70);
var bar = new Node(30);
var qux = new Node(50);

bar.prev = foo;
foo.next = bar;

bar.next = qux;
qux.prev = bar;
----

== push(val)

T.C. stem:[O(1)].

* Create a new node with the value.
* If list is empty:
** Set the new node as both the head and the tail.
* If list is not empty:
** Set next property on the existing tail to the new node.
** Set prev on the new node to the existing tail.
** Set the tail to be the new node.
* Increment the length.
* Return the list (return `this` if doing OO).

== pop()

T.C. stem:[O(1)].

* If the list is empty:
** Return `null`.
* Store current tail (to be returned later).
* If list has one element, set both the head and the tail to `null`.
* If the list has two or more elements:
** Make the node before the current tail to be the new tail.
* Decrement length.
* Return the original tail saved earlier.

It is important to sever the connection of the popped node with the previous node as we don't want the popped node to be still connected with the list.
We don't want lingering connections on the popped node.

== shift()

T.C. stem:[O(1)].

In the context of lists _shift_ means removing a node from the beginning of the list.

 * If length is 0, return `null`.
 * Let `oldHead` be a reference to the head.
 * If length is 1:
 ** Set both head and tail to `null`.
 * If length is greater than 1:
 ** Set the `next` property of the `oldHead` be the new head.
 ** Set this new head's `prev` property to `null`.
 ** Set ``oldHead``'s `next` property to `null`.
 * Decrement the length.
 * Return `oldHead`.

== unshift()

T.C. stem:[O(1)].

In the context of lists, _unshift_ means adding a node to the beginning of the list (add a new head).

* If the length is 0:
** Add the new node as both the head and the tail.
* If the length is 1 or more:
** Set the `prev` property on the head to the new node.
** Set the `next` property on the new node to the head.
** Make the new node to be the head.
* Increment the length.
* Return the list.
