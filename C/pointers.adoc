= C Pointers
:toc: right
:icons: font
:source-highlighter: highlight.js
:stem: latexmath

== Intro

A pointer is a variable that stores the address where a piece of data is located.
It does not store the data itself.
A pointer's “data” is a memory address.
A pointer can point to nothing at all when it is set to `NULL`.
A pointer can be made to point to an _invalid address_, which is then called a _dangling pointer_.

Programming errors that lead to dangling pointers include (non-exhaustive list):

* Cast integers to pointers.
* Access out-of-bounds array locations.
* Deallocate memory which is still being referenced by pointers.

== Storage Allocation

When a pointer is declared, some amount of space in memory is allocated.
A pointer generally take a machine word, but their size can vary depending on the architecture or other things, like compiler settings or type specifiers allowed by certain C implementations.

When a pointer is declared, memory is allocated only for the address the pointer will store, not for the data stored at that address.

Storage for the data can be allocated by declaring a variable for it or by using functions like `malloc` its relatives.

=== Automatic Variables

Automatic variables are those in which allocation and deallocation is handled automatically.
Be extra careful when using pointers to automatic variables:

[source,c]
----
int f(int **iptr) {
  int x = 1;
  *iptr = &x;

  return 0;
}
----

`x` is an automatic variable (after `f()` returns, `x` is deallocated automatically).
When `f()` returns, `x` is deallocated, which means `iptr` has become a dangling pointer.

When memory is dynamically allocated, we are given a pointer to some address on the heap.
That storage remains valid until we deallocate it explicitly.
It remains valid even after the function that allocated it in the first place returns.

== Syntax

`*` is used both to declare a pointer _and_ to access the value the pointer points to.
When it means each is determined by the context.

`int *p = &x` causes `p` to point to the memory address of `x`.

`printf("%d", \*p)` means “look for the address stored in `p` and retrieve the value stored at that address.”
In other words, *read* the value stored at `p`.

`*p = 5` replaces the old value at `p` with 5.

`&` and `*` are opposites.
The former gives the address of something, while the latter gives the value stored at some address.

Pointers are also known as _references_ (to addresses).
`\*` is said to *dereference* a pointer.

== Print pointer address with %p

.invalid type for %p
[source,c]
----
#include <stdio.h>

int main () {
  int *p;
  int x = 3;
  p = &x;

  printf("p addr: %p\n", p);
  printf("*p val: %i\n", *p);
}
----

.compiling
----
$ make ./outdir/ex01ptr
gcc -std=c99 -Wall -pedantic ex01ptr.c -o outdir/ex01ptr
ex01ptr.c: In function ‘main’:
ex01ptr.c:8:20: warning: format ‘%p’ expects argument of type ‘void *’, but argument 2 has type ‘int *’ [-Wformat=]
    8 |   printf("p addr: %p\n", p);
      |                   ~^     ~
      |                    |     |
      |                    |     int *
      |                    void *
      |                   %ls
----

image::./pointers.assets/C-print-pointer-void-error.png[Print pointer address %p invalid (void *)]

Replace:

[source,c]
----
printf("%p", p);
----

with:

[source,c]
----
printf("%p", (void *)p);
----

On Arch Linux:

.man 3 printf on Arch Linux as of 2022
----
p   The void * pointer argument is printed in
    hexadecimal (as if by %#x or %#lx).
----

== sizeof pointers and function parameters

[source,c]
----
#include <stdio.h>

void f(char s[])
{
  printf("f: %ld\n", sizeof(s));
  //=> 8 <2>
}

int main()
{
  char cs[] = "tux";

  printf("main: %ld\n", sizeof(cs));
  //=> 4 <1>

  f(cs);

  return 0;
}
----

1. Size of pointer to char on my machine at the time of this writing.
"tux" is `{ 't', 'u', 'x', '\0' }`.
Three bytes for each char plus one byte for the NUL terminator.

2. In the function, `s` becomes a pointer (to the address of the first char n the original array in main).
On “this machine”, a pointer to char takes 8 bytes.

In `main`, `cs` is a *char array*.
When passed to the `f`, it becomes a (constant) pointer.
