# Haskell Folding



## Parenthesis and the applying of functions

TAGS: 2021-07-24 haskell lists fibonnaci lazy

Parenthesis are used for enforcing precedence. Function application in Haskell is a name followed by a space followed by an argument:

Apply the function `f` to the argument `x`. Read as “f of x”.

```
f x
```

Writing `f(2)` works not because `f()` is invoking a function, but because we are parenthesiz ing the parameter 2 and the ( syntactically separates f from 2. Because of the parentheses, the space is unnecessary (but bad practice, confusing). Do `f 2` instead and use parentheses only when you really need to force precedence or you need to apply a function to the parameter first.

```
f (- 2)
f (negate 2)
```

Note that

```
f x - 1
```

is the same as

```
(f x) - 1
```

## fibs recursive list

TAGS: 2021-07-23 haskell recursion list fibonacci

An implementation of `scanl`.

```
scl :: (a -> b -> a) -> a -> [b] -> [a]
scl f q ls =
  q : (case ls of
        []     -> []
        (x:xs) -> scl f (f q x) xs)
```

Produces an ∞ (infinite) list of fibonacci numbers.

```
fibs :: [Integer]
fibs = 1 : scl (+) 1 fibs
```

On the REPL, use something like `take` to avoid `fibs` from running
forever, infinitely past the end of time.

ℹ️ Note the type definition of `fibs`. It is not a function that takes arguments. It is a list of integers.

```
λ> take 11 fibs
[1,1,2,3,5,8,13,21,34,55,89]
```

Remember that `foldl` and `scanl` use the initial accumulator (aka zero, memo) the first time through, immediately, not when the list is empty, at the end, like `foldr` and `scanr`. That is, it will apply `f` to `q` (our accumulator) already in the first run (`f q x`) in our `scl` implementation.

```
f = (+)
fibs = 1 : scl f 1 fibs → [1]
1 : scl f (f 1 1) fibs → [1, 1]
```

Note that `scl f 1 []` generates 1. That is, 1 is the initial accumulator and is returned when the list is empty. Therefore, we have `1` from the initial `1 : ...` and another `1` from the first value generated by `scl`. It would be `[1, 1]` so far. To be clear, we have 1 *hard-coded*, *consed* 1 which is **not** generated by `scl` (it is generated by the initial `1 : ...`), and another 1 which is indeed the first value generated by `scl` (from the default, initial value for our accumulator). An example with a different initial value for the accumulator:

```
λ> scl f 5 []
[5]

λ> 1 : scl f 5 []
[1,5]
```

So, continuing...

The thing to realize here is that `scanl` (our `scl` implementation also) computes the new value for the accumulator and it is appended the the end of the list on each iteration. It is not really appended, but all the previous values are *consed* (prepended) in front of the list which at each step contains this new accumulator value.

```
f = (+)
fibs = 1 : scl f 1 fibs → [1, 1]
1 : (scl f (f 1 1) fibs) → [1, 1, 2]
             2
1 : (1 : (2 : scl f (f 2 1) fibs)) → [1, 1, 2, 3]
                     3

1 : (1 : (2 : (3 : scl f (f 3 2) fibs))) → [1, 1, 2, 5]
                          5
```

`scl` implementation pattern matches on `x:xs`. `x` is not the always the first 1 though. It is always the *head* of the new *tail* that is generated each time.

So, in...

```
1 : (1 : (2 : scl f (f 2 1) fibs)) → [1, 1, 2, 3]
                     3
```

...3 is the new accumulator, and 2 is the head of the new tail that was just created. In the next iteration, we'll do `f z x`, which is `f 3 2`, producing 5. 5 is the new accumulator, and the previous accumulator 3 is now the head of the new tail, so that we now would do `f 5 3`.

Again, every iteration produces a new tail, which a new x head.

REFERENCES:

- https://mail.haskell.org/pipermail/beginners/2016-October/017165.html
- [recursion - Big 0 of fibonacci number using scanl Haskell - Stack Overflow](https://stackoverflow.com/questions/32576983/big-0-of-fibonacci-number-using-scanl-haskell)
- https://pt.coredump.biz/questions/51131876/fibonacci-series-using-scanl-and-selfreferencing-list
- [The Fibonacci sequence - HaskellWiki](https://wiki.haskell.org/The_Fibonacci_sequence#With_scanl)

## foldr vs foldl accumulator

```
λ> :t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

λ> :t foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
```

The folding function for `foldr` takes an element and the accumulator, while the folding function for `foldr` takes the accumulator and an element. Compare the order.

See with these more meaningful type variables:

```
foldr :: (elem -> acc -> acc) -> acc -> [] elem -> acc
    R     ----    ···

foldl :: (acc -> elem -> acc) -> acc -> [] elem -> acc
    L     ···    ----
```

Do note the inverse order of `acc` and `elem`.

## foldr const 'a' [1..3]

At first sight, it looks like it should work (if we forget about types). But it does not typecheck! `const` allows for different types *a* and *b*, but it does not match with `foldr` type.

In `foldr const 'z' [1, 2, 3]`:

```
const :: a -> b -> a
const :: Int -> Char -> Int

foldr :: (a -> b -> b) ...
foldr :: (Int -> Char -> Char) ...
```

If we compare the types of `const (a -> b -> a)` and the function foldr takes `(a -> b -> b)`, you can see that `a` and `b` have to be the same type. It typechecks if `flip const`.

```
(flip const) :: b -> a -> a
```

## foldr const 0 "string"

```
λ> foldr const 0 "tacos"
```

0 is used as the accumulator, is the last value `foldr` will apply `const` to.

```
const 't' (foldr const 0 "acos")
const 't' (const 'a' (foldr const 0 "cos"))
...
```

`foldr` needs the type the accumulator to be a number because we passed 0 as the initial accumulator. But `const` will try to return its first argument, which is the char `'t'`. Yet, the folding function passed to `foldr` is expected to return something with the type of the accumulator. It does not typecheck.

```
λ> :type foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

λ> :type const
const :: a -> b -> a
```

If we `flip const`, then it returns something of the type of its second argument, and that matches the type expected by `foldr`. But then we get a different result. Let's exemplify with a shorter string.

```
f :: flip const
λ> :t f
f :: b -> c -> c

foldr f 0 "xyz"
f 'x' (foldr f 0 "yz")
f 'x' (f 'y' (foldr f 0 "z"))
f 'x' (f 'y' (f 'z' (foldr f 0 "")))
f 'x' (f 'y' (f 'z' 0))
f 'x' (f 'y' 0)
f 'x' 0
0
```

## foldl flip const 0 "abc"

```
f = flip const
λ> :t f
f :: a -> b -> b

foldl :: (b -> a -> b) -> b -> [] a -> b
foldl _ z [] = z
foldl f z (x:xs) = foldl f (f z x) xs

foldl f 0 "abc"
```

It does not typecheck. `f` (our flipped const) takes an *a* as the first argument, but the folding function for `foldl` expects a *b* as it first argument. The types don't match. It works if we do not `flip const` (contrary to `foldr`, with which we **have to** `flip const`.

Both `foldr` with unfliped `const` and `foldl` with flipped `const` do not
typecheck.

```
λ> foldr (flip const) 0 "xyz"
0

λ> foldl const 0 "xyz"
0

λ> foldr const 0 "xyz"
...ERROR...

λ> foldl (flip const) 0 "xyz"
...ERROR...
```

## foldl (flip const) 'z' [1, 2, 3]

```
f = flip const
λ> :t f
f :: a -> b -> b

foldl :: (b -> a -> b) -> b -> [] a -> b
foldl _ z [] = z
foldl f z (x:xs) = foldl f (f z x) xs

foldl f 'z' [1, 2, 3]
```

Compare:

```
f     ::  a -> b -> b
foldl :: (b -> a -> b)
```

If `f` takes `Char -> Int -> Int`, then `foldl` folding function `(b -> a -> b)` takes `Char -> Int -> Char`. Note the first returns `Int`, while the second returns `Char`. They don't match and thus the failure in typechecking.### Parenthesis and the applying of functions

TAGS: 2021-07-24 haskell lists fibonnaci lazy

Parenthesis are used for enforcing precedence. Function application in Haskell is a name followed by a space followed by an argument:

Apply the function `f` to the argument `x`. Read as “f of x”.

```
f x
```

Writing `f(2)` works not because `f()` is invoking a function, but because we are parenthesising the parameter 2 and the ( syntactically separates f from 2. Because of the parentheses, the space is unnecessary (but bad practice, confusing). Do `f 2` instead and use parentheses only when you really need to force precedence or you need to apply a function to the parameter first.

```
f (- 2)
f (negate 2)
```

Note that

```
f x - 1
```

is the same as

```
(f x) - 1
```

## fibs recursive list

TAGS: 2021-07-23 haskell recursion list fibonacci

An implementation of `scanl`.

```
scl :: (a -> b -> a) -> a -> [b] -> [a]
scl f q ls =
  q : (case ls of
        []     -> []
        (x:xs) -> scl f (f q x) xs)
```

Produces an ∞ (infinite) list of fibonacci numbers.

```
fibs :: [Integer]
fibs = 1 : scl (+) 1 fibs
```

On the REPL, use something like `take` to avoid `fibs` from running
forever, infinitely past the end of time.

ℹ️ Note the type definition of `fibs`. It is not a function that takes arguments. It is a list of integers.

```
λ> take 11 fibs
[1,1,2,3,5,8,13,21,34,55,89]
```

Remember that `foldl` and `scanl` use the initial accumulator (aka zero, memo) the first time through, immediately, not when the list is empty, at the end, like `foldr` and `scanr`. That is, it will apply `f` to `q` (our accumulator) already in the first run (`f q x`) in our `scl` implementation.

```
f = (+)
fibs = 1 : scl f 1 fibs → [1]
1 : scl f (f 1 1) fibs → [1, 1]
```

Note that `scl f 1 []` generates 1. That is, 1 is the initial accumulator and is returned when the list is empty. Therefore, we have `1` from the initial `1 : ...` and another `1` from the first value generated by `scl`. It would be `[1, 1]` so far. To be clear, we have 1 *hard-coded*, *consed* 1 which is **not** generated by `scl` (it is generated by the initial `1 : ...`), and another 1 which is indeed the first value generated by `scl` (from the default, initial value for our accumulator). An example with a different initial value for the accumulator:

```
λ> scl f 5 []
[5]

λ> 1 : scl f 5 []
[1,5]
```

So, continuing...

The thing to realize here is that `scanl` (our `scl` implementation also) computes the new value for the accumulator and it is appended the the end of the list on each iteration. It is not really appended, but all the previous values are *consed* (prepended) in front of the list which at each step contains this new accumulator value.

```
f = (+)
fibs = 1 : scl f 1 fibs → [1, 1]
1 : (scl f (f 1 1) fibs) → [1, 1, 2]
             2
1 : (1 : (2 : scl f (f 2 1) fibs)) → [1, 1, 2, 3]
                     3

1 : (1 : (2 : (3 : scl f (f 3 2) fibs))) → [1, 1, 2, 5]
                          5
```

`scl` implementation pattern matches on `x:xs`. `x` is not the always the first 1 though. It is always the *head* of the new *tail* that is generated each time.

So, in...

```
1 : (1 : (2 : scl f (f 2 1) fibs)) → [1, 1, 2, 3]
                     3
```

...3 is the new accumulator, and 2 is the head of the new tail that was just created. In the next iteration, we'll do `f z x`, which is `f 3 2`, producing 5. 5 is the new accumulator, and the previous accumulator 3 is now the head of the new tail, so that we now would do `f 5 3`.

Again, every iteration produces a new tail, which a new x head.

REFERENCES:

- https://mail.haskell.org/pipermail/beginners/2016-October/017165.html
- [recursion - Big 0 of fibonacci number using scanl Haskell - Stack Overflow](https://stackoverflow.com/questions/32576983/big-0-of-fibonacci-number-using-scanl-haskell)
- [haskell - Fibonacci série usando scanl e auto-referência lista - CoreDump.biz](https://pt.coredump.biz/questions/51131876/fibonacci-series-using-scanl-and-selfreferencing-list)
- [The Fibonacci sequence - HaskellWiki](https://wiki.haskell.org/The_Fibonacci_sequence#With_scanl)

## foldr vs foldl accumulator

```
λ> :t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

λ> :t foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
```

The folding function for `foldr` takes an element and the accumulator, while the folding function for `foldr` takes the accumulator and an element. Compare the order.

See with these more meaningful type variables:

```
foldr :: (elem -> acc -> acc) -> acc -> [] elem -> acc
    R     ----    ···

foldl :: (acc -> elem -> acc) -> acc -> [] elem -> acc
    L     ···    ----
```

Do note the inverse order of `acc` and `elem`.

## foldr const 'a' [1..3]

At first sight, it looks like it should work (if we forget about types). But it does not typecheck! `const` allows for different types *a* and *b*, but it does not match with `foldr` type.

In `foldr const 'z' [1, 2, 3]`:

```
const :: a -> b -> a
const :: Int -> Char -> Int

foldr :: (a -> b -> b) ...
foldr :: (Int -> Char -> Char) ...
```

If we compare the types of `const (a -> b -> a)` and the function foldr takes `(a -> b -> b)`, you can see that `a` and `b` have to be the same type. It typechecks if `flip const`.

```
(flip const) :: b -> a -> a
```

## foldr const 0 "string"

```
λ> foldr const 0 "tacos"
```

0 is used as the accumulator, is the last value `foldr` will apply `const` to.

```
const 't' (foldr const 0 "acos")
const 't' (const 'a' (foldr const 0 "cos"))
...
```

`foldr` needs the type the accumulator to be a number because we passed 0 as
the initial accumulator. But `const` will try to return its first argument,
which is the char `'t'`. Yet, the folding function passed to `foldr` is
expected to return something with the type of the accumulator. It does not typecheck.

```
λ> :type foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

λ> :type const
const :: a -> b -> a
```

If we `flip const`, then it returns something of the type of its second
argument, and that matches the type expected by `foldr`. But then we get a
different result. Let's exemplify with a shorter string.

```
f :: flip const
λ> :t f
f :: b -> c -> c

foldr f 0 "xyz"
f 'x' (foldr f 0 "yz")
f 'x' (f 'y' (foldr f 0 "z"))
f 'x' (f 'y' (f 'z' (foldr f 0 "")))
f 'x' (f 'y' (f 'z' 0))
f 'x' (f 'y' 0)
f 'x' 0
0
```

## foldl flip const 0 "abc"

```
f = flip const
λ> :t f
f :: a -> b -> b

foldl :: (b -> a -> b) -> b -> [] a -> b
foldl _ z [] = z
foldl f z (x:xs) = foldl f (f z x) xs

foldl f 0 "abc"
```

It does not typecheck. f (our flipped const) takes an *a* ast the first
argument, but the folding function for `foldl` expects a *b* as it first
argument. The types don't match. It works if we do not `flip const` (contraty
to `foldr`, with which we **have to** `flip const`.

Both `foldr` with unfliped `const` and `foldl` with flipped `const` do not
typecheck.

```
λ> foldr (flip const) 0 "xyz"
0

λ> foldl const 0 "xyz"
0

λ> foldr const 0 "xyz"
...ERROR...

λ> foldl (flip const) 0 "xyz"
...ERROR...
```

## foldl (flip const) 'z' [1, 2, 3]

```
f = flip const
λ> :t f
f :: a -> b -> b

foldl :: (b -> a -> b) -> b -> [] a -> b
foldl _ z [] = z
foldl f z (x:xs) = foldl f (f z x) xs

foldl f 'z' [1, 2, 3]
```

Compare:

```
f     ::  a -> b -> b
foldl :: (b -> a -> b)
```

If `f` takes `Char -> Int -> Int`, then `foldl` folding function `(b -> a -> b)` takes `Char -> Int -> Char`. Note the first returns `Int`, while the second returns `Char`. They don't match and thus the failure in typechecking.

![](/Users/fernando/Sync-pCloud/MDNotes/Personal/assets/2021-07-25-08-05-16-image.png)
