= Array Tips
:page-tags: array algorithm
:toc: right
:stem:
:icons: font

[data-date="2022-10-29",data-tags="array swap"]
== Swap array element

.stood the test of time
----
tmp = xs[idx1];
xs[idx1] = xs[idx2];
xs[idx2] = tmp;
----

Not all languages allow something like this:

.smart approach
----
[xs[idx1], xs[idx2] = [xs[idx2], idx[1]]
----

.ES6 example:
----
$ deno repl (or node --interactive):

> var chars = ['a', 'c', 'b'];

> [chars[1], chars[2] = chars[2], chars[1]]
[ "c", "b", "c" ]

> chars
[ "a", "c", "b" ]
----

[source,javascript,lineos]
----
function swap(
  xs: number[],
  idx1: number,
  idx2: number,
): void {
  [xs[idx1], xs[idx2]] = [xs[idx2], xs[idx1]];
}
----

* https://stackoverflow.com/questions/872310/javascript-swap-array-elements#comment131093228_872317[Javascript swap array elements (StackOverflow)^]

## Array.prototype.fill() problemâ€½

.node repl session example
[source,text]
----
$ node --interactive

> var buckets = Array(10).fill([]);

> buckets
[
  [], [], [], [], [],
  [], [], [], [], []
]

> buckets[5].push(35);
1
> buckets
[
  [ 35 ], [ 35 ],
  [ 35 ], [ 35 ],
  [ 35 ], [ 35 ],
  [ 35 ], [ 35 ],
  [ 35 ], [ 35 ]
]
----

Want to push 35 to the 5th bucket, but all of the buckets get filled ðŸ˜­.

The problem seems to be `Array(10).fill()`, because this works:

[source,text]
----
> var buckets = [[], [], [], [], [], [], [], [], [], []];

> buckets.length
10
> buckets[5].push(35);
1
> buckets
[
  [], [], [],
  [], [], [ 35 ],
  [], [], [],
  []
]
----

Note only sub-array at index 5 got pushed the value 35.

See link:https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.fill[the spec] and link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill[MDN docs].

image:./arrays.assets/ecmascript-array-fill.png[]

> pass:[[...]]changes all elements in an array to a *static* value[...]
> -- MDN Docs on Array.prototype.fill()

It all means when we fill with `[]` (which is a reference type and not a primitive), all positions are filled with the same object in memory, and not 10 different empty arrays.
It is the same array in memory, used 10 times.

=== Clever approach

OK, we can manually do this:

----
[[], [], [], [], [] (many more []s here...)]
----

But what if we need 100 or 500 (ore more) sub-arrays?

----
$ deno repl
Deno 1.28.2

> var xs = Array.from({ length: 1e5 }, () => []);

> xs.length
100000

> Array.from({ length: 10 }, () => []);
[
  [], [], [], [], [],
  [], [], [], [], []
]
----

This works because the anonymous arrow function is invoked each for each one of the stem:[1 \times 10 ^ 5] (100_000) elements we want to create so we end up with 100000 different empty array references in memory.

And note it creates an array containing `length` arrays.

[TIP]
====
Did you know we can write 100_000_000 instead of 100000000 in ECMAScript to make large numbers more readableâ€½
====

== Concatenate (flatten) arrays

First, let's see the basics of how `Array.prototype.concat()` works:

.deno repl simple concat()
----
$ deno repl

> var a1 = [10, 20];
> var a2 = [30, 40];

> var all = a1.concat(a2);

> all
[ 10, 20, 30, 40 ]
----

Note the result is *not* something like:

----
[[10, 20], [30, 40]]
----

No, it is instead a flat result of the `a1` and `a2`.
Of course, both `a1` and `a2` are flat themselves, so, concat'ing them produces a flat result.

.deno repl flatten (NOK)
----
> var xs = [[10, 20], [30, 40], [50, 60]];

> var flat = [].concat(xs);

> flat
[ [ 10, 20 ], [ 30, 40 ], [ 50, 60 ] ]
----

We still got an array with nested arrays instead of a flattened array with all elements of the original sub-arrays...

One solution:

.deno repl flatten loop (OK)
----
var xs = [[10, 20], [30, 40], [50, 60]];

> var flat = [];
> for (var i = 0; i < xs.length; ++i)
    flat = flat.concat(xs[i]);

> flat
[ 10, 20, 30, 40, 50, 60 ]
----

But note how we have to reassign `flat` (`concat()` does not modify the receiver).

Another solution is this:

.deno repl flatten spread (OK)
----
> var xs = [[10, 20], [30, 40], [50, 60]];

> var flat = [].concat(...xs);

> flat
[ 10, 20, 30, 40, 50, 60 ]
----

This works because `...xs` will expand to each individual sub-array, which are each concat'ed correctly and we end up with a flattened array.
